/*
                ⠀⠀⠀⠀⠀⢀⣠⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⢀⣴⠿⢫⣯⣍⣉⠙⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⣰⠟⣱⡾⠛⢿⣿⣿⣷⠀⣿⡻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⣸⡏⣼⣿⣿⣷⣤⡉⠻⡿⠀⡟⠿⡎⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⣿⠀⡟⠳⣽⡻⣿⣿⡾⠃⣼⠃⠀⠉⠲⣌⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⢿⡄⠻⣦⣬⣽⡾⠋⣠⡞⠙⢢⠀⠑⢦⡀⣸⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠈⠻⣶⣤⣤⣤⣶⢿⡉⠀⠀⠀⡀⠈⠙⣿⣿⢱⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠉⠛⠷⣌⡓⠯⡳⢄⡀⠈⢳⣴⡿⢻⣿⠄⠀⠈⠻⢦⡄⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠈⠙⠳⢦⠤⠵⢾⣿⣯⣿⣷⡃⠀⠀⠀⠀⠀⠙⢿⣟⠛⣋⣉⣉⣉⣉⣉⡉⠉⠉⢙⡟⠳⢦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢯⣕⢯⠲⣄⠀⠀⠀⠀⠀⠙⢿⣿⠟⠿⠻⠿⠿⢭⡇⠀⢸⠃⣰⣤⣌⡙⠳⢦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢶⣄⠙⠶⣔⠦⣄⠀⠓⣾⣷⠀⠀⠀⠈⢸⡇⠀⣾⠀⡟⠒⠈⠉⠓⠶⣬⣹⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣷⣦⣈⡓⢈⣓⣶⣿⠋⡄⠀⠀⠀⣿⠀⢀⡇⣠⣇⣀⣀⣀⣀⡐⢺⡇⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⠛⣿⣿⣿⡟⠛⠿⠛⠋⢁⣴⣁⣤⠤⠶⠿⠶⠾⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⢾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡴⠶⠶⠶⠛⠛⢻⡿⣿⡿⠷⠿⠛⠛⠛⠛⠛⠛⢩⡟⡁⢠⠖⠀⠀⡀⣠⡶⠻⣷⣄⣈⠉⠛⠻⠿⣼⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⢀⡼⠋⣠⢢⡀⢠⠆⣴⣿⡾⢋⡄⠀⠀⠀⡴⠀⠀⠀⣴⣋⣼⣵⣃⣀⣤⣾⡿⠋⣠⡾⢻⣯⡙⠓⢶⣦⣤⣈⠙⠛⢦⣤⡀⠀⠀⠀⠀⠀
                ⠀⠀⠀⠀⠀⠀⢠⣾⠥⢾⠷⢿⣾⡿⣿⣿⡟⢁⡞⠀⡤⢀⣞⡇⠀⣠⠚⢻⣤⣮⣤⣤⣽⣽⣽⣷⡾⣿⣶⣿⠿⠿⠿⣿⡷⣤⣍⣻⠶⣦⣈⠙⢷⣤⡀⠀⠀
                ⠀⠀⠀⠀⠀⠀⠀⢹⡷⡶⢺⣿⡛⡿⣻⢿⡶⠿⠺⡟⠛⠋⠉⠉⢻⡉⢹⣿⣦⣴⣤⣿⣦⣾⣾⣫⡴⣿⠟⣴⢾⣿⣶⣌⢻⣦⣍⡙⠳⣦⣍⡿⢦⡈⠻⣦⡄
                ⠀⠀⠀⠀⠀⠀⠀⢿⡗⠻⣿⣻⠻⡛⢻⡌⢻⡄⠀⠓⠀⠘⣦⡄⠀⠓⠈⢿⡘⠈⢯⠻⡼⠈⢿⡈⢷⣿⠀⣿⣿⣉⣿⣿⢈⡿⢿⡿⣿⢿⣿⣿⣦⣙⣷⣼⠇
                ⠀⠀⠀⠀⠀⠀⠀⠈⢿⣄⣹⣥⣷⣧⣄⣿⣾⢿⡄⢷⡀⠀⠸⡾⡄⢠⡸⣌⣿⣤⣬⢦⡿⢤⡼⣿⠟⣿⣆⠹⢿⣿⡿⢋⣼⣇⣸⣿⣬⣻⣿⣿⣿⣿⣧⠛⣦
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⡄⣤⡽⡆⡄⢹⣄⢻⣟⣿⣿⣿⣿⢛⣿⣿⣿⣿⣷⡹⢬⡃⢀⢣⠘⣇⠘⣟⢳⣶⣦⠶⣿⣿⣾⣿⣿⣿⣿⣏⣿⣾⣿⣿⠿⣿
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡶⠾⠷⢷⠾⠶⡿⣟⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡶⠷⣾⠷⣶⡾⣟⠹⣿⣶⣿⠿⢿⣿⣿⣿⠿⣷⣿⡿⣿⣿⠿⣧⡾⠃
                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣆⢲⡈⢳⡄⠁⠹⣆⡽⠿⠿⢿⡿⢿⠿⢿⠿⢿⣿⣷⣄⣘⠲⡜⠁⠻⣤⡿⠙⠋⢻⡏⠉⠙⣿⠉⠙⣟⠉⢹⣧⣴⠏⠀⠀
                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠁⠀⠀⠀

 ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄         ▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░▌
▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░▌       ▐░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀█░▌
▐░▌          ▐░▌          ▐░▌       ▐░▌▐░▌       ▐░▌▐░▌          ▐░▌       ▐░▌▐░▌          ▐░▌       ▐░▌
▐░█▄▄▄▄▄▄▄▄▄ ▐░▌          ▐░▌       ▐░▌▐░█▄▄▄▄▄▄▄█░▌▐░▌          ▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░▌       ▐░▌
▐░░░░░░░░░░░▌▐░▌          ▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░▌          ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌
 ▀▀▀▀▀▀▀▀▀█░▌▐░▌          ▐░▌       ▐░▌▐░█▀▀▀▀█░█▀▀ ▐░▌          ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░▌       ▐░▌
          ▐░▌▐░▌          ▐░▌       ▐░▌▐░▌     ▐░▌  ▐░▌          ▐░▌       ▐░▌▐░▌          ▐░▌       ▐░▌
 ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌▐░▌      ▐░▌ ▐░█▄▄▄▄▄▄▄▄▄ ▐░▌       ▐░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░▌
 ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀         ▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀         ▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀


This is a rough clone of my favourite old DOS game, Scorched Earth. It's a work in progress, not playable yet.
*/

use bevy::{
    prelude::*,
    render::{
        render_asset::RenderAssetUsages,
        render_resource::{Extent3d, TextureDimension, TextureFormat},
    },
    sprite::MaterialMesh2dBundle,
};
use noise::{NoiseFn, Perlin, Seedable};
use rand::{Rng, RngCore};
use simple_moving_average::{SumTreeSMA, SMA};

fn main() {
    App::new()
        // .insert_resource(ImageSettings::default_nearest()) // Ensure nearest-neighbor scaling
        .add_plugins(DefaultPlugins)
        .add_event::<FireProjectile>()
        .add_systems(Startup, setup)
        .add_systems(
            FixedUpdate,
            (
                rotate_turret,
                fire_projectile,
                move_projectile,
                adjust_power,
                update_ui,
                update_terrain,
            ),
        )
        .run();
}

#[derive(Component)]
struct UiText;

#[derive(Component)]
struct Tank;

#[derive(Component)]
struct Angle(f32);

#[derive(Component)]
struct Power(f32);

#[derive(Component)]
struct Projectile {
    velocity: Vec2,
    blast_radius: f32,
}

#[derive(Component)]
struct Terrain;

#[derive(Component)]
struct Turret;

#[derive(Component)]
struct TerrainTexture(Handle<Image>);

#[derive(Event, Default)]
struct FireProjectile;

const MINIMUM_POWER: f32 = 250.;
const TANK_COLOR: Color = Color::srgb(0.0, 1.0, 0.0);
const TURRET_COLOR: Color = Color::srgb(0.1, 0.7, 0.1);
const TANK_RADIUS: f32 = 10.;
const TURRET_LENGTH: f32 = TANK_RADIUS * 2.;
const TURRET_WIDTH: f32 = TANK_RADIUS / 2.;
const GRAVITY: f32 = -980.;
const TURRET_ROTATION_SPEED: f32 = 0.5; // rotations per second

impl Projectile {
    fn new((angle, power): (&Angle, &Power)) -> Self {
        let angle = angle.0.to_radians();
        let velocity = Vec2::new(angle.cos(), angle.sin()) * (power.0 + MINIMUM_POWER);
        Projectile {
            velocity,
            blast_radius: 50.,
        }
    }
}

fn get_terrain_height(
    images: &ResMut<Assets<Image>>,
    texture_handle: &Handle<Image>,
    x: f32,
    window_height: f32,
) -> f32 {
    if let Some(texture) = images.get(texture_handle) {
        let width = texture.size().x as f32;
        let height = texture.size().y as f32;
        let x = (x + width / 2.0).clamp(0.0, width - 1.0) as u32;

        for y in 0..height as u32 {
            let index = (y * texture.size().x + x) as usize * 4;
            if texture.data[index + 3] != 0 {
                let flipped_y = height as u32 - 1 - y; // Flip the y-coordinate
                return flipped_y as f32 - height / 2.0;
            }
        }
    }
    -window_height / 2.0
}

fn setup(
    mut commands: Commands,
    window_query: Query<&Window>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
    mut images: ResMut<Assets<Image>>,
) {
    let window = window_query.single();
    // Camera
    commands.spawn(Camera2dBundle::default());

    commands.spawn((
        UiText,
        TextBundle::from_sections([
            TextSection::new(
                "Power: ",
                TextStyle {
                    font_size: 20.0,
                    color: TANK_COLOR,
                    ..default()
                },
            ),
            TextSection::from_style(TextStyle {
                font_size: 20.0,
                color: TANK_COLOR,
                ..default()
            }),
            TextSection::new(
                " Angle: ",
                TextStyle {
                    font_size: 20.0,
                    color: TANK_COLOR,
                    ..default()
                },
            ),
            TextSection::from_style(TextStyle {
                font_size: 20.0,
                color: TANK_COLOR,
                ..default()
            }),
        ]),
    ));

    // Create the terrain texture
    let texture_size = Extent3d {
        width: window.width() as u32,
        height: window.height() as u32,
        depth_or_array_layers: 1,
    };
    let mut texture = Image::new_fill(
        texture_size,
        TextureDimension::D2,
        &[0, 0, 0, 0],
        TextureFormat::Rgba8UnormSrgb,
        RenderAssetUsages::default(),
    );

    // Generate the initial terrain using Perlin noise
    let mut rng = rand::thread_rng();
    let perlin = Perlin::default().set_seed(rng.next_u32());
    let mut ma = SumTreeSMA::<_, f32, 200>::new();

    for x in 0..texture_size.width {
        let y_raw = perlin.get([x as f64 * 0.005, x as f64 * 0.001]) as f32 * 800.;
        ma.add_sample(y_raw.abs());
        let y = ma.get_average();

        for y_cur in 0..(y as u32) {
            let flipped_y = texture_size.height - 1 - y_cur;
            let index = (flipped_y * texture_size.width + x) as usize * 4;
            texture.data[index] = 255; // R
            texture.data[index + 1] = 255; // G
            texture.data[index + 2] = 255; // B
            texture.data[index + 3] = 255; // A
        }
    }

    let texture_handle = images.add(texture);

    // Spawn the terrain entity with the texture
    commands.spawn((
        SpriteBundle {
            texture: texture_handle.clone(),
            transform: Transform::from_translation(Vec3::new(0., 0., 0.)),
            ..default()
        },
        Terrain,
        TerrainTexture(texture_handle.clone()),
    ));

    let tank_x = rand::thread_rng().gen_range(-window.width() / 2.0..window.width() / 2.0);
    let tank_y = get_terrain_height(&images, &texture_handle, tank_x, window.height());
    // Tank body
    commands
        .spawn((
            MaterialMesh2dBundle {
                mesh: meshes
                    .add(CircularSector::from_degrees(TANK_RADIUS, 180.))
                    .into(),
                material: materials.add(TANK_COLOR),
                transform: Transform::from_translation(Vec3::new(tank_x, tank_y, 1.)),
                ..default()
            },
            Tank,
        ))
        .with_children(|tank| {
            // Turret of the tank
            tank.spawn((
                MaterialMesh2dBundle {
                    // this is the axis of the turret, this simplifies the rotation
                    mesh: meshes
                        .add(Rectangle::from_size(Vec2::new(
                            TURRET_LENGTH * 2.,
                            TURRET_WIDTH,
                        )))
                        .into(),
                    material: materials.add(ColorMaterial::default()),
                    visibility: Visibility::Hidden,
                    transform: Transform {
                        translation: Vec3::new(0., TURRET_WIDTH / 2., -1.),
                        ..default()
                    },
                    ..default()
                },
                Turret,
                Angle(0.),
                Power(500.),
            ))
            .with_children(|turret_axis| {
                // Turret barrel
                turret_axis.spawn((MaterialMesh2dBundle {
                    mesh: meshes
                        .add(Rectangle::from_size(Vec2::new(TURRET_LENGTH, TURRET_WIDTH)))
                        .into(),
                    material: materials.add(TURRET_COLOR),
                    visibility: Visibility::Visible,
                    transform: Transform {
                        translation: Vec3::new(TURRET_LENGTH / 2., 0., 0.),
                        ..default()
                    },
                    ..default()
                },));
            });
        });
}

fn fire_projectile(
    keyboard_input: Res<ButtonInput<KeyCode>>,
    query: Query<(&Angle, &Power, &GlobalTransform), With<Turret>>,
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
    mut events: EventWriter<FireProjectile>,
) {
    let (angle, power, transform) = query.single();
    if keyboard_input.just_pressed(KeyCode::Space) {
        events.send(FireProjectile);
        commands.spawn((
            MaterialMesh2dBundle {
                mesh: meshes.add(Rectangle::from_length(TANK_RADIUS / 5.)).into(),
                material: materials.add(ColorMaterial::default()),
                visibility: Visibility::Visible,
                transform: Transform::from_translation(Vec3::new(
                    transform.translation().x,
                    transform.translation().y,
                    -2.,
                )),
                ..Default::default()
            },
            Projectile::new((angle, power)),
        ));
    }
}

fn move_projectile(mut query: Query<(&mut Transform, &mut Projectile)>, time: Res<Time>) {
    for (mut transform, mut projectile) in query.iter_mut() {
        projectile.velocity.y += GRAVITY * time.delta_seconds();
        transform.translation += projectile.velocity.extend(1.) * time.delta_seconds();
    }
}

fn rotate_turret(
    keyboard_input: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Transform, &mut Angle), With<Turret>>,
    time: Res<Time>,
) {
    for (mut transform, mut angle) in query.iter_mut() {
        let mut rotation_factor = 0.;

        if keyboard_input.pressed(KeyCode::ArrowLeft) {
            rotation_factor += 1.;
        }
        if keyboard_input.pressed(KeyCode::ArrowRight) {
            rotation_factor -= 1.;
        }

        let rotation_speed_degrees = TURRET_ROTATION_SPEED * 360.0; // Convert rotation speed to degrees per second
        let rotation_amount = rotation_factor * rotation_speed_degrees * time.delta_seconds();

        // Update the angle
        angle.0 += rotation_amount;

        if angle.0 > 180. {
            angle.0 = 0.;
        } else if angle.0 < 0. {
            angle.0 = 180.;
        }

        // Apply the rotation in degrees
        transform.rotation = Quat::from_rotation_z(angle.0.to_radians());
    }
}

fn adjust_power(
    keyboard_input: Res<ButtonInput<KeyCode>>,
    mut query: Query<&mut Power, With<Turret>>,
    time: Res<Time>,
) {
    for mut power in query.iter_mut() {
        let mut power_factor = 0.;

        if keyboard_input.pressed(KeyCode::ArrowUp) {
            power_factor += 1.;
        }
        if keyboard_input.pressed(KeyCode::ArrowDown) {
            power_factor -= 1.;
        }

        let power_speed = 500.0; // power per second
        let power_amount = power_factor * power_speed * time.delta_seconds();

        // Update the power
        power.0 += power_amount;

        // Clamp to within 0 to 1000
        power.0 = power.0.clamp(0.0, 1000.0);
    }
}

fn update_ui(
    query: Query<(&Power, &Angle), With<Turret>>,
    mut ui_query: Query<&mut Text, With<UiText>>,
) {
    let (power, angle) = query.single();
    let mut ui_text = ui_query.single_mut();
    ui_text.sections[1].value = format!("{: >4.0}", power.0);
    ui_text.sections[3].value = format!("{:.1}", angle.0);
}

fn create_explosion(texture: &mut Image, x: u32, y: u32, radius: f32) {
    let width = texture.size().x;
    let height = texture.size().y;
    let radius_squared = radius * radius;

    for dx in -(radius as i32)..=(radius as i32) {
        for dy in -(radius as i32)..=(radius as i32) {
            let distance_squared = (dx * dx + dy * dy) as f32;
            if distance_squared <= radius_squared {
                let nx = x as i32 + dx;
                let ny = y as i32 + dy;

                if nx >= 0 && nx < width as i32 && ny >= 0 && ny < height as i32 {
                    let index = (ny as u32 * width + nx as u32) as usize * 4;
                    texture.data[index] = 0; // R
                    texture.data[index + 1] = 0; // G
                    texture.data[index + 2] = 0; // B
                    texture.data[index + 3] = 0; // A
                }
            }
        }
    }
}

fn update_terrain(
    mut commands: Commands,
    mut query: Query<(Entity, &mut Transform, &mut Projectile)>,
    mut terrain_query: Query<&Handle<Image>, With<TerrainTexture>>,
    mut images: ResMut<Assets<Image>>,
    time: Res<Time>,
) {
    for (entity, mut transform, mut projectile) in query.iter_mut() {
        projectile.velocity.y += GRAVITY * time.delta_seconds();
        transform.translation += projectile.velocity.extend(1.) * time.delta_seconds();

        // Check for collision with terrain and update the texture
        for texture_handle in terrain_query.iter_mut() {
            if let Some(texture) = images.get_mut(texture_handle) {
                let x = (transform.translation.x + texture.size().x as f32 / 2.0) as u32;
                let y = (transform.translation.y + texture.size().y as f32 / 2.0) as u32;

                if x < texture.size().x && y < texture.size().y {
                    let flipped_y = texture.size().y - 1 - y; // Flip the y-coordinate
                    let index = (flipped_y * texture.size().x + x) as usize * 4;

                    // Check if the projectile hits the terrain
                    if texture.data[index + 3] != 0 {
                        // Create an explosion effect
                        create_explosion(texture, x, flipped_y, projectile.blast_radius);

                        // Remove the projectile
                        commands.entity(entity).despawn();
                    }
                }
            }
        }
    }
}
